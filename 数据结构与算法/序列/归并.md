# 归并

给定两个有序的数组，合并成一个大的有序数组。

### 算法描述

每次取出两个数组中的较小元素。当一个数组输出完毕时，依次输出另一个数组的剩余部分。

##### 示例

将有序数组 08 21 25 25* 49 62 72 93 和 16 37 54 合并成一个有序数组。


| 结果 | 数组1 | 数组2 |
|---|---|---|
| | 08 21 25 25* 49 62 72 93 | 16 37 54 |
| 08 | 21 25 25* 49 62 72 93 | 16 37 54 |
| 08 16| 21 25 25* 49 62 72 93 | 37 54 |
| 08 16 21 | 25 25* 49 62 72 93 | 37 54 |
| 08 16 21 25 | 25* 49 62 72 93 | 37 54 |
| 08 16 21 25 25* | 49 62 72 93 | 37 54 |
| 08 16 21 25 25* 37 | 49 62 72 93 | 54 |
| 08 16 21 25 25* 37 49 | 62 72 93 | 54 |
| 08 16 21 25 25* 37 49 54 | 62 72 93 | |
| 08 16 21 25 25* 37 49 54 62 | 72 93 | |
| 08 16 21 25 25* 37 49 54 62 72 | 93 | |
| 08 16 21 25 25* 37 49 54 62 72 93 | | |

### 算法分析

时间复杂度：O(n)

稳定性：稳定

### 实现

##### Java
``` Java
public static <T> T[] merge(T[] array1, T[] array2, T[] result, Comparator<T> comparator)
{
    // assert(result.length >= array1.length + array2.length)
    
	int i = 0, j = 0, k = 0;
	while(i < array1.length && j < array2.length){
		if(comparator.compare(array1[i], array2[j]) <= 0){
			result[k++] = array1[i++];
		}
		else{
			result[k++] = array2[j++];
		}
	}
	while(i < array1.length){
		result[k++] = array1[i++];
	}
	while(j < array2.length){
		result[k++] = array2[j++];
	}
}
```