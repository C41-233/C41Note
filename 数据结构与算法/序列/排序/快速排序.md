# 快速排序

## 算法描述

在n个数的数组中，取定一个数作为基准，把小于等于它的数分划到它的左侧，把大于它的数分划到它的右侧，分划时原先元素的相对顺序可以保持不变，左右两侧可以为空。随后递归地对左右两侧进行划分。

## 划分
基准可以有多种选取方式。

#### 1. 取第一个数为基准
1. 令i=start，j=end，其中array[i]是基准元素
2. 从右向左寻找，令j=第一个小于等于基准的元素位置
3. array[i] = array[j]
4. 从左向右寻找，令i=第一个大于基准的元素位置
5. array[j] = array[i]
6. 重复步骤2，直到i>=j
7. 最后，i处于基准位置，令array[i] = 基准元素

##### 示例

基准为46，i为红色，j为蓝色

<table>
    <tr><td><strong style="color:red">46</strong> 13 55 42 94 05 17 70 82 <strong style="color:blue">100</strong></td><td>初始</td></tr>
    <tr><td><strong style="color:red">46</strong> 13 55 42 94 05 <strong style="color:blue">17</strong> 70 82 100</td><td>向左寻找</td></tr>
    <tr><td><strong style="color:red">17</strong> 13 55 42 94 05 <strong style="color:blue">17</strong> 70 82 100</td><td>替换</td></tr>
    <tr><td>17 13 <strong style="color:red">55</strong> 42 94 05 <strong style="color:blue">17</strong> 70 82 100</td><td>向右寻找</td></tr>
    <tr><td>17 13 <strong style="color:red">55</strong> 42 94 05 <strong style="color:blue">55</strong> 70 82 100</td><td>替换</td></tr>
    <tr><td>17 13 <strong style="color:red">55</strong> 42 94 <strong style="color:blue">05</strong> 55 70 82 100</td><td>向左寻找</td></tr>
    <tr><td>17 13 <strong style="color:red">05</strong> 42 94 <strong style="color:blue">05</strong> 55 70 82 100</td><td>替换</td></tr>
    <tr><td>17 13 05 42 <strong style="color:red">94</strong> <strong style="color:blue">05</strong> 55 70 82 100</td><td>向右寻找</td></tr>
    <tr><td>17 13 05 42 <strong style="color:red">94</strong> <strong style="color:blue">94</strong> 55 70 82 100</td><td>替换</td></tr>
    <tr><td>17 13 05 42 <strong style="color:red">46</strong> <strong style="color:blue">94</strong> 55 70 82 100</td><td>基准</td></tr>
</table>

#### 2. 取最后一个数为基准

不断把右侧小于等于基准的元素交换到左侧来。

1. 令i=start-1, j=start，array[end]为基准。
2. j不断递进到end-1，每当array[j]小于等于基准时：
    1. 递进i，并。
    2. 交换array[i]与array[j]。（交换时，i指向左侧第一个大于基准的元素，j指向右侧第一个小于等于基准的元素）
3. 最后，i+1指向第一个大于基准的元素，交换array[i+1]和array[end]

##### 示例

基准为100，i为红色，j为蓝色

<table>
    <tr><td><strong style="color:blue">46</strong> 13 55 42 94 05 17 70 82 100</td><td>初始</td></tr>
    <tr><td>46 <strong style="color:blue">13</strong> 55 42 94 05 17 70 82 100</td><td>初始</td></tr>
</table>

## 实现 

递归实现，选取第一个数为基准。

##### Java
``` Java
public static <T> void quickSort(T[] array, Comparator<T> comparator){
	quick_sort(array, 0, array.length-1, comparator);
}

private static <T> void quick_sort(T[] array, int start, int end, Comparator<T> comparator) {
    if(start > end){
        return;
    }
	int i = start, j = end;
	T key = array[start];
	while(i < j){
		while(i < j && comparator.compare(array[j], key) >= 0){
			j--;
		}
		if(i < j){
			array[i] = array[j];
		}
		while(i < j && comparator.compare(array[i], key) < 0){
			i++;
		}
		if(i < j){
			array[j] = array[i];
		}
	}
	array[i] = key;
	quick_sort(array, start, i-1, comparator);
	quick_sort(array, j+1, end, comparator);
}
```

##### C#
``` C#
public static void QuickSort<T>(T[] array, Comparison<T> comparator)
{
    QuickSort(array, 0, array.Length - 1, comparator);
}

private static void QuickSort<T>(T[] array, int start, int end, Comparison<T> comparator)
{
    if (start > end)
    {
        return;
    }
    int i = start, j = end;
    T key = array[start];
    while (i < j)
    {
        while (i < j && comparator(array[j], key) >= 0)
        {
            j--;
        }
        if (i < j)
        {
            array[i] = array[j];
        }
        while (i < j && comparator(array[i], key) < 0)
        {
            i++;
        }
        if (i < j)
        {
            array[j] = array[i];
        }
    }
    array[i] = key;
    QuickSort(array, start, i - 1, comparator);
    QuickSort(array, j + 1, end, comparator);
}
```

递归实现，选取最后一个数为基准。

##### C#
``` C#
public static void QuickSort<T>(T[] array, Comparison<T> comparator)
{
    QuickSort(array, 0, array.Length - 1, comparator);
}

private static void QuickSort<T>(T[] array, int start, int end, Comparison<T> comparator)
{
    if (start < end)
    {
        var p = Partition(array, start, end, comparator);
        QuickSort(array, start, p - 1, comparator);
        QuickSort(array, p + 1, end, comparator);
    }
}

private static int Partition<T>(T[] array, int start, int end, Comparison<T> comparator)
{
    var target = array[end];
    var i = start - 1;
    for (var j = start; j < end; j++)
    {
        if (comparator(array[j], target) <= 0)
        {
            i++;
            Swap(ref array[i], ref array[j]);
        }
    }

    Swap(ref array[i + 1], ref array[end]);
    return i + 1;
}
```