# TimSort

TimSort是一个归并排序的优化版本，对归并排序在已经反向排序的输入时表现O(n<sup>2</sup>)的特点做了优化。对于已经部分排序的数组，时间复杂度远低于 O(nlogn)，最好可达 O(n)，对于随机排序的数组，时间复杂度为 O(nlogn)，平均时间复杂度 O(nlogn)。

TimSort为了减少对升序部分的回溯和对降序部分的性能倒退，将输入按其升序和降序特点进行了分区。排序的输入的单位不是一个个单独的元素了，而是一个个的分区。其中每一个分区叫一个run。针对这个run序列，每次拿一个run出来参与归并。每次归并会将两个run合并成一个run。归并的结果保存到run栈上。

每一个run必须是一个非严格递增的序列，当遇到严格递减的序列时将其翻转（必须是严格递减的序列才能翻转，为了保证稳定性）。

run栈必须保证深度不超过log(n)，栈中的相邻3个run的长度 X、Y、Z必须满足：X>Y+Z且Y>Z，它们依次在以下条件下进行合并（两路归并）：
1. 栈顶三个元素满足X<=Y+Z，若X>Z，则合并Y和Z，否则合并X和Y。
2. 栈顶两个元素满足Y<=Z，则合并Y和Z。

##### 示例

<table>
	<thead>
	<tr>
		<th>run栈中元素</th>
		<th>剩余元素</th>
		<th>描述</th>
	</tr>
	</thead>
	<tbody>
		<tr><td></td><td>7,5,1,2,6,8,10,12,4,3,9,11,13,15,16,14</td><td>初始序列</td></tr>
		<tr><td>[1,5,7]</td><td>2,6,8,10,12,4,3,9,11,13,15,16,14</td><td>寻找run并入栈，栈大小为[3]，不合并</td></tr>
		<tr><td>[1,5,7] [2,6,8,10,12]</td><td>4,3,9,11,13,15,16,14</td><td>寻找run并入栈，栈大小为[3,5]，此时Y&lt;=Z，进行YZ合并</td></tr>
		<tr><td>[1,2,5,6,7,8,10,12]</td><td>4,3,9,11,13,15,16,14</td><td>合并，栈大小为[8]，不合并</td></tr>
		<tr><td>[1,2,5,6,7,8,10,12] [3,4]</td><td>9,11,13,15,16,14</td><td>寻找run并入栈，栈大小为[8,2]，此时Y&gt;Z，不合并</td></tr>
		<tr><td>[1,2,5,6,7,8,10,12] [3,4] [9,11,13,15,16]</td><td>14</td><td>寻找run并入栈，栈大小为[8,2,5]，此时X&gt;Y+Z，但Y&lt;=Z，进行YZ合并</td></tr>
		<tr><td>[1,2,5,6,7,8,10,12] [3,4,9,11,13,15,16]</td><td>14</td><td>合并，栈大小为[8,7]，此时Y&gt;Z，不合并</td></tr>
		<tr><td>[1,2,5,6,7,8,10,12] [3,4,9,11,13,15,16] [14]</td><td></td><td>寻找run并入栈，栈大小为[8,7,1]，此时X&lt;=Y+Z，X&gt;Z，进行YZ合并</td></tr>
		<tr><td>[1,2,5,6,7,8,10,12] [3,4,9,11,13,14,15,16]</td><td></td><td>合并，栈大小为[8,8]，此时Y&lt;=Z，进行YZ合并</td></tr>
		<tr><td>[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]</td><td></td><td>合并，完成</td></tr>
	</tbody>
</table>

