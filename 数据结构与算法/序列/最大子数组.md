# 最大子数组

给定一个数组，求出使得元素的和最大的连续子数组。

## 分治策略
给定一个mid，将问题划分为三个子问题：（1）mid左侧的最大子数组，（2）mid右侧的最大子数组，（3）跨越mid的最大子数组，三者中的最大者即为结果。

求解跨越mid的最大子数组，只需要求出以mid为右边界的左侧最大子数组，以及以mid为左边界的右侧最大子数组，二者合并即可。

时间复杂度为O(nlogn)

``` C#
public static void FindMaxSubArray(int[] array, out int left, out int right, out int sum)
{
    var range = FindMaxSubArray(array, 0, array.Length - 1);
    left = range.Left;
    right = range.Right;
    sum = range.Sum;
}

private struct Range
{
    public int Left;
    public int Right;
    public int Sum;
}

private static Range FindMaxSubArray(int[] array, int from, int to)
{
    if (from == to)
    {
        return new Range
        {
            Left = from,
            Right = to,
            Sum = array[from],
        };
    }

    var mid = (from + to) / 2;
    var left = FindMaxSubArray(array, from, mid);
    var right = FindMaxSubArray(array, mid + 1, to);
    var cross = FindMaxCrossSubArray(array, from, mid, to);

    if (left.Sum >= right.Sum && left.Sum >= cross.Sum)
    {
        return left;
    }
    if (right.Sum >= left.Sum && right.Sum >= cross.Sum)
    {
        return right;
    }

    return cross;
}

private static Range FindMaxCrossSubArray(int[] array, int from, int mid, int to)
{
    var range = new Range();
    var left_sum = int.MinValue;
    var right_sum = int.MinValue;
    {
        var sum = 0;
        for (var i = mid; i >= from; i--)
        {
            sum += array[i];
            if (sum > left_sum)
            {
                left_sum = sum;
                range.Left = i;
            }
        }
    }
    {

        var sum = 0;
        for (var j=mid + 1; j<=to; j++)
        {
            sum += array[j];
            if (sum > right_sum)
            {
                right_sum = sum;
                range.Right = j;
            }
        }
    }
    range.Sum = left_sum + right_sum;
    return range;
}

```